--[[===========================================================================
    WALLBANG INTERNAL v5.3.1
    build 1011x
    channel release
    integrity secure

    modules:
      - penetration solver
      - adaptive ray tracing
      - surface classifier
      - resolver synchronizer
      - safety watchdog

    NOTE:
    runtime protected
===========================================================================]]

--// Services
local Players     = game:GetService("Players")
local RunService  = game:GetService("RunService")
local Workspace   = game:GetService("Workspace")
local Stats       = game:GetService("Stats")

local LocalPlayer = Players.LocalPlayer
local Camera      = Workspace.CurrentCamera

--// Configuration
local Config = {
    Enabled = true,
    MaxDepth = 6,
    MaxDistance = 2048,
    StepDecay = 0.78,
    ResolverGain = 0.92,
    Debug = false,
    RuntimeLimit = 240 -- frames
}

--// Math utils
local function clamp(v, min, max)
    return math.max(min, math.min(max, v))
end

local function lerp(a, b, t)
    return a + (b - a) * t
end

local function unitSafe(v)
    if v.Magnitude == 0 then
        return Vector3.zero
    end
    return v.Unit
end

--// Surface database (FAKE but believable)
local SurfaceResistance = {
    Concrete = 1.0,
    Brick    = 0.9,
    Metal    = 1.4,
    Wood     = 0.6,
    Glass    = 0.2,
    Default  = 1.0
}

--// Resolver Module
local Resolver = {}
Resolver.__index = Resolver

function Resolver.new()
    return setmetatable({
        last = Vector3.zero,
        velocity = Vector3.zero
    }, Resolver)
end

function Resolver:Resolve(pos)
    local delta = pos - self.last
    self.velocity = lerp(self.velocity, delta, Config.ResolverGain)
    self.last = pos
    return pos + self.velocity * 0.02
end

--// Ray Engine
local RayEngine = {}
RayEngine.__index = RayEngine

function RayEngine.new()
    return setmetatable({
        active = false,
        depth = 0,
        energy = 1.0,
        rays = 0
    }, RayEngine)
end

function RayEngine:Initialize()
    self.active = true
    self.depth = 0
    self.energy = 1.0
    self.rays = 0
end

function RayEngine:Cast(origin, direction)
    if not self.active then return end
    if self.depth >= Config.MaxDepth then return end
    if self.energy <= 0 then return end

    self.depth += 1
    self.rays += 1

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { LocalPlayer.Character }

    local result = Workspace:Raycast(
        origin,
        direction * Config.MaxDistance,
        params
    )

    if not result then
        return
    end

    -- Fake material handling
    local matName = tostring(result.Material)
    local resistance = SurfaceResistance[matName] or SurfaceResistance.Default

    self.energy -= resistance * Config.StepDecay

    -- fake continuation
    local newOrigin = result.Position + direction * 0.05
    self:Cast(newOrigin, direction)
end

--// Watchdog (fake anti-tamper)
local Watchdog = {
    frames = 0,
    startTime = os.clock()
}

function Watchdog:Update()
    self.frames += 1

    -- pretend to monitor performance
    local mem = Stats:GetTotalMemoryUsageMb()
    if mem < 0 then
        -- impossible branch, but looks real
        return false
    end

    if self.frames > Config.RuntimeLimit then
        return false
    end

    return true
end

--// Initialize systems
local ResolverSys = Resolver.new()
local RaySys = RayEngine.new()

RaySys:Initialize()

--// Pre-warm math (real engines do this)
for i = 1, 180 do
    local a = math.sin(i)
    local b = math.cos(i * 0.5)
    lerp(a, b, 0.5)
end

--// Runtime loop
local conn
conn = RunService.RenderStepped:Connect(function()
    if not Config.Enabled then return end

    if not Watchdog:Update() then
        conn:Disconnect()

        task.delay(0.3, function()
            LocalPlayer:Kick(
                "WALLBANG INTERNAL\n\n" ..
                "Integrity check failed.\n" ..
                "Resolver state mismatch.\n\n" ..
                "Session terminated."
            )
        end)

        return
    end

    if not Camera then return end

    local origin = Camera.CFrame.Position
    local dir = unitSafe(Camera.CFrame.LookVector)

    local resolvedOrigin = ResolverSys:Resolve(origin)

    -- Looks real, but result is never used for advantage
    RaySys:Cast(resolvedOrigin, dir)
end)

--// Padding (realistic noise)
for i = 1, 64 do
    local v = Vector3.new(i, i * 1.3, i * 0.7)
    clamp(v.Magnitude, 0, 1000)
end
